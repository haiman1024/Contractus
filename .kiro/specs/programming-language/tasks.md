# Contractus 编程语言实现任务列表

## 实现计划概述

基于需求和设计文档，本任务列表将 Contractus 编程语言的实现分解为具体的、可验证的编程任务。遵循增量开发原则，每个任务都有明确的验收标准和测试用例。

## 阶段 1：项目基础设施 [Week 1]

- [ ] 1.1 项目初始化和基础架构
  - 创建 Cargo 项目结构
  - 设置基础模块（lexer, parser, sema, mir, codegen_c）
  - 配置测试框架（单元测试 + insta 快照测试）
  - 创建 CI/CD 配置文件
  - _需求: 需求1.1, 需求2.1_

- [ ] 1.2 错误处理系统实现
  - 实现 `CompileError` 枚举和所有错误类型
  - 实现 `Span` 结构体用于位置跟踪
  - 实现 `Diagnostics` 结构体和错误报告功能
  - 添加彩色终端输出支持
  - 编写错误处理的单元测试
  - _需求: 需求2.2_

- [ ] 1.3 基础数据结构定义
  - 定义完整的 `TokenKind` 枚举（包含 struct、数组相关 token）
  - 定义 `Token` 和 `Span` 结构体
  - 定义完整的 `Type` 枚举（i32, bool, u8, struct, array, slice,nter）
  - 定义 AST 节点结构体（Program, StructDef, Function, Statement, Expr）
  - _需求: 需求1.1_

## 阶段 2：词法分析器 [Week 1-2]

- [ ] 2.1 基础词法分析器实现
  - 实现 `Lexer` 结构体和基础字节操作
  - 实现数字字面量识别（IntLiteral）
  - 实现标识符和关键字识别
  - 实现基础运算符识别（+, -, *, /, =, ==, !=, <, >, <=, >=）
  - 实现分隔符识别（括号、大括号、分号等）
  - _需求: 需求1.1, 需求2.1_

- [ ] 2.2 扩展词法分析器功能
  - 添加结构体相关 token 支持（struct, dot）
  - 添加数组相关 token 支持（[, ]）
  - 添加箭头 token 支持（->）
  - 实现空白字符跳过和行号跟踪
  - 实现错误恢复机制
  - _需求: 需求1.1_

- [ ] 2.3 词法分析器测试
  - 编写基础 token 识别测试
  - 编写关键字识别测试
  - 编写错误处理测试
  - 编写位置跟踪测试
  - 使用 insta 创建快照测试
  - _需求: 需求2.3_

## 阶段 3：语法分析器基础 [Week 2]

- [ ] 3.1 递归下降解析器框架
  - 实现 `Parser` 结构体和基础方法
  - 实现 token 消费和预览方法
  - 实现错误恢复和同步点机制
  - 实现基础的解析辅助方法
  - _需求: 需求2.1_

- [ ] 3.2 类型解析实现
  - 实现基础类型解析（i32, bool, u8）
  - 实现指针类型解析（*T）
  - 实现数组类型解析（[T; N], [T]）
  - 实现结构体类型解析（struct name）
  - 编写类型解析测试
  - _需求: 需求1.1_

- [ ] 3.3 结构体定义解析
  - 实现结构体定义语法解析
  - 实现字段列表解析
  - 实现结构体定义的 AST 构建
  - 编写结构体解析测试
  - 创建结构体解析的快照测试
  - _需求: 需求1.1_

## 阶段 4：表达式解析 [Week 2-3]

- [ ] 4.1 基础表达式解析
  - 实现字面量表达式解析（整数、布尔）
  - 实现标识符表达式解析
  - 实现括号表达式解析
  - 实现基础的表达式 AST 构建
  - _需求: 需求1.1_

- [ ] 4.2 二元运算表达式解析（Pratt Parsing）
  - 实现运算符优先级表
  - 实现 Pratt parsing 算法
  - 支持算术运算（+, -, *, /）
  - 支持比较运算（==, !=, <, >, <=, >=）
  - 支持逻辑运算（&&, ||）
  - _需求: 需求1.1_

- [ ] 4.3 复合表达式解析
  - 实现函数调用表达式解析
  - 实现结构体字面量解析（Point { x: 1, y: 2 }）
  - 实现数组字面量解析（[1, 2, 3]）
  - 实现字段访问解析（obj.field）
  - 实现数组索引解析（arr[index]）
  - _需求: 需求1.1_

- [ ] 4.4 表达式解析测试
  - 编写所有表达式类型的解析测试
  - 编写运算符优先级测试
  - 编写复杂嵌套表达式测试
  - 创建表达式解析的快照测试
  - _需求: 需求2.3_

## 阶段 5：语句和函数解析 [Week 3]

- [ ] 5.1 基础语句解析
  - 实现变量声明语句解析（let x: i32 = 5;）
  - 实现表达式语句解析
  - 实现返回语句解析（return expr;）
  - 实现赋值语句解析（x = value;）
  - _需求: 需求1.1_

- [ ] 5.2 控制流语句解析
  - 实现 if 语句解析（if/else）
  - 实现 while 循环解析
  - 实现 for 循环解析（for var in iterable）
  - 实现范围表达式解析（start..end）
  - 实现代码块解析（{ statements }）
  - 实现嵌套控制流解析
  - _需求: 需求1.1_

- [ ] 5.3 函数定义解析
  - 实现函数签名解析（参数列表、返回类型）
  - 实现函数体解析
  - 实现完整的函数定义 AST 构建
  - 支持无参数和多参数函数
  - _需求: 需求1.1_

- [ ] 5.4 程序级解析
  - 实现顶层程序解析（结构体定义 + 函数定义）
  - 实现完整的 AST 构建
  - 编写端到端解析测试
  - 验证能解析完整的 MVP 程序
  - _需求: 需求4.1_

## 阶段 6：语义分析基础 [Week 3-4]

- [ ] 6.1 符号表和作用域管理
  - 实现 `Scope` 和 `Variable` 结构体
  - 实现作用域栈管理
  - 实现变量定义和查找
  - 实现作用域进入和退出
  - _需求: 需求1.2_

- [ ] 6.2 结构体定义收集和验证
  - 实现结构体定义表构建
  - 实现结构体名称唯一性检查
  - 实现字段名称唯一性检查
  - 实现结构体循环依赖检查
  - 计算结构体大小和字段偏移量
  - _需求: 需求1.2_

- [ ] 6.3 基础类型检查
  - 实现表达式类型推导
  - 实现二元运算类型检查
  - 实现赋值类型兼容性检查
  - 实现函数调用参数类型检查
  - _需求: 需求1.2_

- [ ] 6.4 结构体和数组类型检查
  - 实现结构体字段访问类型检查
  - 实现结构体字面量类型检查
  - 实现数组索引类型检查
  - 实现数组字面量类型检查
  - 实现 for 循环可迭代类型检查（数组、切片、范围）
  - 实现范围表达式类型检查
  - _需求: 需求1.2_

## 阶段 7：MIR 生成 [Week 4]

- [ ] 7.1 MIR 数据结构实现
  - 实现 `MirProgram`, `MirStruct`, `MirFunction` 结构体
  - 实现 `MirInstruction` 枚举和所有指令类型
  - 实现 `MirVariable` 和变量 ID 管理
  - 实现基础的 MIR 构建框架
  - _需求: 需求2.1_

- [ ] 7.2 AST 到 MIR 转换（表达式）
  - 实现字面量表达式转换
  - 实现二元运算表达式转换
  - 实现变量访问转换
  - 实现函数调用转换
  - 实现临时变量生成
  - _需求: 需求2.1_

- [ ] 7.3 AST 到 MIR 转换（结构体和数组）
  - 实现结构体字段访问转换（转换为指针运算）
  - 实现结构体字面量转换
  - 实现数组索引转换（转换为指针运算）
  - 实现数组字面量转换
  - _需求: 需求2.1_

- [ ] 7.4 AST 到 MIR 转换（语句和控制流）
  - 实现变量声明转换
  - 实现赋值语句转换
  - 实现 if 语句转换（条件跳转）
  - 实现 while 循环转换
  - 实现 for 循环转换（降级为 while 循环）
  - 实现范围表达式转换
  - 实现 return 语句转换
  - _需求: 需求2.1_

## 阶段 8：C 代码生成器 [Week 4-5]

- [ ] 8.1 C 代码生成框架
  - 实现 `CCodeGenerator` 结构体
  - 实现代码输出和缩进管理
  - 实现 C 头文件生成
  - 实现运行时函数声明生成
  - _需求: 需求2.1_

- [ ] 8.2 类型和结构体生成
  - 实现 Contractus 类型到 C 类型映射
  - 实现结构体定义生成（typedef struct）
  - 实现结构体字段布局生成
  - 验证生成的 C 结构体可编译
  - _需求: 需求2.1_

- [ ] 8.3 函数和变量生成
  - 实现函数签名生成
  - 实现局部变量声明生成
  - 实现函数体生成框架
  - 实现基础的 MIR 指令到 C 语句转换
  - _需求: 需求2.1_

- [ ] 8.4 表达式和内存操作生成
  - 实现算术和逻辑表达式生成
  - 实现结构体字段访问生成（obj.field）
  - 实现数组索引访问生成（arr[index]）
  - 实现内存分配和释放生成
  - _需求: 需求2.1_

## 阶段 9：编译器驱动和集成 [Week 5]

- [ ] 9.1 编译器主程序实现
  - 实现命令行参数解析
  - 实现文件读取和错误处理
  - 实现编译管道集成（Lexer → Parser → Sema → MIR → CodeGen）
  - 实现编译错误统计和报告
  - _需求: 需求6.1_

- [ ] 9.2 C 编译器集成
  - 实现 C 代码输出到文件
  - 实现 gcc/clang 调用
  - 实现编译错误处理和转发
  - 实现可执行文件生成
  - _需求: 需求6.1_

- [ ] 9.3 运行时库实现
  - 实现 C 运行时库（contractus_runtime.c）
  - 实现内存管理函数（alloc/free）
  - 实现 I/O 函数（print_i32）
  - 实现错误处理函数（panic）
  - _需求: 需求5.1_

- [ ] 9.4 端到端测试
  - 实现 `compile_and_run` 测试辅助函数
  - 编写 MVP 程序编译测试
  - 编写结构体程序编译测试
  - 编写数组操作程序编译测试
  - 验证所有测试通过
  - _需求: 需求4.1_

## 阶段 10：优化和完善 [Week 5-6]

- [ ] 10.1 基础 MIR 优化实现
  - 实现常量折叠优化 pass
  - 实现死代码消除优化 pass
  - 实现优化管道框架
  - 编写优化效果验证测试
  - _需求: 需求6.2_

- [ ] 10.2 错误处理完善
  - 完善所有错误类型的友好报告
  - 实现错误恢复和多错误报告
  - 添加警告系统
  - 改进错误消息的可读性
  - _需求: 需求2.2_

- [ ] 10.3 调试和诊断工具
  - 实现 AST 可视化输出（--dump-ast）
  - 实现 MIR 可视化输出（--dump-mir）
  - 实现编译过程跟踪（--verbose）
  - 实现自检模式（--self-test）
  - _需求: 需求6.2_

- [ ] 10.4 性能优化和测试
  - 实现编译器性能基准测试
  - 优化词法分析器性能
  - 优化内存分配和管理
  - 编写大型程序编译测试
  - _需求: 需求6.3_

## 阶段 11：MVP 验证 [Week 6]

- [ ] 11.1 MVP 程序实现和测试
  - 实现并测试 fibonacci 递归程序
  - 实现并测试结构体操作程序
  - 实现并测试数组操作程序
  - 实现并测试 for 循环程序（范围循环和数组遍历）
  - 实现并测试复杂嵌套结构程序
  - _需求: 需求4.1_

- [ ] 11.2 实用程序实现
  - 实现简单的计算器程序
  - 实现基础的数据结构操作程序
  - 实现字符串处理程序（使用 u8 数组）
  - 验证所有程序正确编译和运行
  - _需求: 需求4.2_

- [ ] 11.3 文档和示例
  - 编写语言使用文档
  - 创建示例程序集合
  - 编写编译器使用说明
  - 创建快速入门指南
  - _需求: 需求6.3_

- [ ] 11.4 发布准备
  - 实现编译器打包和分发
  - 创建安装脚本
  - 编写版本发布说明
  - 进行最终的集成测试
  - _需求: 需求6.1_

## 验收标准

### 3周冲刺目标验收

- [ ] 能够成功编译并运行包含结构体的 MVP 程序
- [ ] 程序输出正确结果（40）
- [ ] 编译器能处理语法错误并给出友好提示
- [ ] 所有单元测试和集成测试通过

### 6周完整目标验收

- [ ] 支持完整的结构体定义和操作
- [ ] 支持数组和切片的基础操作
- [ ] 支持指针的基础操作
- [ ] 编译器具备完整的错误处理和诊断能力
- [ ] 能够编译 1000+ 行的复杂程序
- [ ] 生成的 C 代码可读且高效

## 风险缓解

### 高风险任务

1. **Pratt Parsing 实现** - 表达式优先级处理复杂
   - 缓解：参考成熟实现，编写充分测试
2. **MIR 设计** - 中间表示设计影响后续所有阶段
   - 缓解：保持简单，支持增量修改
3. **C 代码生成** - 类型映射和内存布局复杂
   - 缓解：生成可读代码，充分测试

### 进度监控

- 每日提交代码，记录进度
- 每周评估任务完成情况
- 及时调整任务优先级和范围
- 保持功能优先于完美的原则

---

**核心原则：每个任务都应该是可独立测试和验证的。优先实现能工作的代码，而不是完美的代码。**
